{"version":3,"sources":["../../../src/components/sandbox/sandbox.js"],"names":["Sandbox","sandboxStyle","bgWhite","elevation1","borderRadius","DOM","store","example$","pluck","skip","distinctUntilChanged","map","exampleKey","examples","publishReplay","refCount","inputStores$","switchMap","example","filter","identity","startWith","inputs","outputStore$","outputTimelineSources$","marbles","end","interactive","Observable","of","inputTimelines$","Collection","gather","Timeline","outputTimeline","inputDOMs$","inputDataList$","length","debounceTime","withLatestFrom","zip","merge","vtree$","combineLatest","inputsDOMs","outputDOM","style","label","data"],"mappings":";;;;;QAkBgBA,O,GAAAA,O;;AAlBhB;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AAEA;;AAEA;;AACA;;AACA;;AAAqD;AAGrD,MAAMC,YAAY,GAAG,kBAAYC,eAAZ,EAAqBC,iBAArB,EAAiC;AAAEC,EAAAA,YAAY,EAAE;AAAhB,CAAjC,CAArB;;AAEO,SAASJ,OAAT,CAAiB;AAAEK,EAAAA,GAAF;AAAOC,EAAAA;AAAP,CAAjB,EAAiC;AACtC,QAAMC,QAAQ,GAAGD,KAAK,CAACE,KAAN,CAAY,OAAZ,EACdC,IADc,CACT,CADS,EACN;AADM,GAEdC,oBAFc,GAGdC,GAHc,CAGVC,UAAU,IAAIC,eAASD,UAAT,CAHJ,EAIdE,aAJc,CAIA,CAJA,EAIGC,QAJH,EAAjB;AAMA,QAAMC,YAAY,GAAGT,QAAQ,CAC1BU,SADkB,CACRC,OAAO,IAChBZ,KAAK,CAACE,KAAN,CAAY,QAAZ,EACGW,MADH,CACUC,eADV,EAEE;AACA;AAHF,GAIGX,IAJH,CAIQ,CAJR,EAKGY,SALH,CAKa,qCAAkBH,OAAO,CAACI,MAA1B,CALb,CAFiB,EASlBR,aATkB,CASJ,CATI,EASDC,QATC,EAArB;AAWA,QAAMQ,YAAY,GAAG,wCAAoBhB,QAApB,EAA8BS,YAA9B,CAArB;AACA,QAAMQ,sBAAsB,GAAG;AAC7BnB,IAAAA,GAD6B;AAE7BoB,IAAAA,OAAO,EAAEF,YAAY,CAACf,KAAb,CAAmB,SAAnB,CAFoB;AAG7BkB,IAAAA,GAAG,EAAEH,YAAY,CAACf,KAAb,CAAmB,KAAnB,CAHwB;AAI7BmB,IAAAA,WAAW,EAAEC,iBAAWC,EAAX,CAAc,KAAd;AAJgB,GAA/B;;AAOA,QAAMC,eAAe,GACjBC,uBAAWC,MAAX,CAAkBC,kBAAlB,EAA4B;AAAE5B,IAAAA;AAAF,GAA5B,EAAqCW,YAArC,EAAmD,IAAnD,EACCF,aADD,CACe,CADf,EACkBC,QADlB,EADJ;;AAGA,QAAMmB,cAAc,GAAG,wBAASV,sBAAT,CAAvB;;AAEA,QAAMW,UAAU,GAAGJ,uBAAWvB,KAAX,CAAiBsB,eAAjB,EAAkC,iBAAK,KAAL,CAAlC,CAAnB;;AACA,QAAMM,cAAc,GAAGL,uBAAWvB,KAAX,CAAiBsB,eAAjB,EAAkC,iBAAK,MAAL,CAAlC,EACpBX,MADoB,CACbkB,aADa,EAEpBC,YAFoB,CAEP,CAFO,EAGpBC,cAHoB,CAGLvB,YAHK,EAGSwB,UAHT,EAIpB7B,GAJoB,CAIhB,gBAAI,kBAAM,iBAAK8B,YAAL,CAAN,CAAJ,CAJgB,CAAvB;;AAMA,QAAMC,MAAM,GAAGd,iBACZe,aADY,CACER,UADF,EACcD,cAAc,CAAC7B,GAD7B,EACkCE,QADlC,EAEZI,GAFY,CAER,CAAC,CAACiC,UAAD,EAAaC,SAAb,EAAwB3B,OAAxB,CAAD,KACH,cAAI;AAAE4B,IAAAA,KAAK,EAAE7C;AAAT,GAAJ,EAA6B,CAC3B,GAAG2C,UADwB,EAE3B,sCAAkB1B,OAAO,CAAC6B,KAA1B,CAF2B,EAG3BF,SAH2B,CAA7B,CAHW,CAAf;;AAUA,SAAO;AACLxC,IAAAA,GAAG,EAAEqC,MADA;AAELM,IAAAA,IAAI,EAAEZ,cAAc,CAACzB,GAAf,CAAoBW,MAAD,KAAa;AAAEA,MAAAA;AAAF,KAAb,CAAnB;AAFD,GAAP;AAID","sourcesContent":["import { div } from '@cycle/dom';\nimport { Observable } from 'rxjs';\nimport { apply, flip, identity, length, map, merge, prop, zip } from 'ramda';\n\nimport { Collection } from '../../collection';\nimport { examples } from '../../data';\nimport { bgWhite } from '../../styles';\nimport { merge as mergeStyles, elevation1 } from '../../styles/utils';\n\nimport { Timeline } from '../timeline';\n\nimport { createOutputStream$ } from './sandbox-output';\nimport { inputsToTimelines } from './sandbox-input';\nimport { renderOperatorBox } from './operator-label';;\n\n\nconst sandboxStyle = mergeStyles(bgWhite, elevation1, { borderRadius: '2px' });\n\nexport function Sandbox({ DOM, store }) {\n  const example$ = store.pluck('route')\n    .skip(1) // blank first route\n    .distinctUntilChanged()\n    .map(exampleKey => examples[exampleKey])\n    .publishReplay(1).refCount();\n\n  const inputStores$ = example$\n    .switchMap(example =>\n      store.pluck('inputs')\n        .filter(identity)\n        // bug: For some reason inputDataList$ emits old value after\n        // route change. Skip it.\n        .skip(1)\n        .startWith(inputsToTimelines(example.inputs))\n    )\n    .publishReplay(1).refCount();\n\n  const outputStore$ = createOutputStream$(example$, inputStores$);\n  const outputTimelineSources$ = {\n    DOM,\n    marbles: outputStore$.pluck('marbles'),\n    end: outputStore$.pluck('end'),\n    interactive: Observable.of(false),\n  };\n\n  const inputTimelines$\n    = Collection.gather(Timeline, { DOM }, inputStores$, 'id')\n      .publishReplay(1).refCount()\n  const outputTimeline = Timeline(outputTimelineSources$);\n\n  const inputDOMs$ = Collection.pluck(inputTimelines$, prop('DOM'));\n  const inputDataList$ = Collection.pluck(inputTimelines$, prop('data'))\n    .filter(length)\n    .debounceTime(0)\n    .withLatestFrom(inputStores$, zip)\n    .map(map(apply(flip(merge))));\n\n  const vtree$ = Observable\n    .combineLatest(inputDOMs$, outputTimeline.DOM, example$)\n    .map(([inputsDOMs, outputDOM, example]) =>\n      div({ style: sandboxStyle }, [\n        ...inputsDOMs,\n        renderOperatorBox(example.label),\n        outputDOM,\n      ]),\n    );\n\n  return {\n    DOM: vtree$,\n    data: inputDataList$.map((inputs) => ({ inputs })),\n  };\n}\n"],"file":"sandbox.js"}